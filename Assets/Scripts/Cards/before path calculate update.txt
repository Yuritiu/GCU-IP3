using System.Collections;
using System.Collections.Generic;
using System.IO;
using TMPro;
using UnityEngine;

public class S1Behaviour : SteeringAgent
{
    [Header("Debug Variables")]
    [SerializeField] TextMeshProUGUI squadStatusText;

    [Header("Detection Variables")]
    public bool enemyInVision = false;
    public bool inFiringRange = false;
    public bool inDirectorSquare;

    [Header("Vision Cone Variables")]
    [SerializeField] float visionDistance = 40f;
    [SerializeField] float firingRange = 20f;
    [SerializeField] LayerMask obstacleLayerMask;

    [Header("Movement Variables")]
    [SerializeField] public float moveSpeed = 1f;
    [SerializeField] public const float raycastDistance = 2f;
    [SerializeField] public const float avoidanceDistance = 1f;
    [SerializeField] public const float directorSquareRange = 10f;
    Rigidbody2D rb;
    SpriteRenderer spriteRenderer;

    private Vector2 lastPosition;
    private float timeStationary;

    [Header("Attack Variables")]
    Attack.AttackType attackType;

    Vector2 targetCenter;

    [Header("Path Settings")]
    public Vector2 targetPosition;
    public List<Vector2> path = new List<Vector2>(); // Stores the calculated path
    bool isPathCalculated = false;
    bool unstuckCalled = false;

    protected override void InitialiseFromAwake()
    {
        // Add RB At Runtime
        if (GetComponent<Rigidbody2D>() == null)
        {
            rb = gameObject.AddComponent<Rigidbody2D>();
            rb.isKinematic = true;
            rb.collisionDetectionMode = CollisionDetectionMode2D.Continuous;
        }
        else
        {
            rb = GetComponent<Rigidbody2D>();
        }
        obstacleLayerMask = LayerMask.GetMask("Obstacle");

        lastPosition = transform.position;
        timeStationary = 0f;

        attackType = Attack.AttackType.None;
        moveSpeed = 5f;

        spriteRenderer = GetComponent<SpriteRenderer>();

        squadStatusText = GameObject.FindGameObjectWithTag("Squad1StatusText").GetComponent<TextMeshProUGUI>();
        Debug.Log("S1 Behaviour Script Created");
    }

    protected override void InitialiseFromStart()
    {
        if (Director.Instance != null)
        {
            //TODO: CHANGE TO BE CLOSEST ENEMIES
            targetPosition = new Vector2(75, 25);
            StartCoroutine(DelayedPathCalculation());
        }
    }

    IEnumerator DelayedPathCalculation()
    {
        //Wait To Allow Obstacles To Spawn
        yield return new WaitForSeconds(0.5f);

        CalculatePath();

        isPathCalculated = true;
    }

    //Calculates The Path From The Agent To The Target -> Avoiding Obstacles
    void CalculatePath()
    {
        Vector2 currentPosition = transform.position;
        Vector2 directionToTarget = (targetPosition - currentPosition).normalized;

        //Clear Previous Path
        path.Clear();
        //Start With The Current Position
        path.Add(currentPosition);

        int maxIterations = 1000;
        int iterationCount = 0;

        while (Vector2.Distance(currentPosition, targetPosition) > 5f && iterationCount < maxIterations)
        {
            //Ray Ahead To Detect Obstacles
            RaycastHit2D hit = Physics2D.Raycast(currentPosition, directionToTarget, raycastDistance, obstacleLayerMask);

            if (hit.collider != null)
            {
                // Handle obstacle detection and avoidance
                Vector2 avoidanceDirection = Vector2.Perpendicular(hit.normal).normalized;

                // Calculate a direct detour point that steers the agent around the obstacle
                Vector2 detourPoint = currentPosition + avoidanceDirection * raycastDistance;
                // Ensure the detour is straight, no curves
                path.Add(detourPoint);

                currentPosition = detourPoint;

                // Recalculate the direction to the target after avoidance
                directionToTarget = (targetPosition - currentPosition).normalized;
            }
            else
            {
                //No Obstacle Detected -> Move Straight To Target
                path.Add(targetPosition);
                //Target Reached
                break;
            }

            iterationCount++;
        }
    }

    protected override void CooperativeArbitration()
    {
        Vector2 agentPosition = transform.position;
        Vector2 directionToTarget = (targetPosition - agentPosition).normalized;

        Director.Instance.UpdateTargetQuadrant(agentPosition);

        // Track movement over time
        float distanceMoved = Vector2.Distance(agentPosition, lastPosition);

        if (distanceMoved < 0.1f) // Threshold to detect minimal movement
        {
            timeStationary += Time.deltaTime;
        }
        else
        {
            timeStationary = 0f; // Reset stationary timer if movement occurs
        }

        lastPosition = agentPosition;

        // Check if agent has been stationary for over a second and there's an obstacle in front
        RaycastHit2D hitForward = Physics2D.Raycast(agentPosition, directionToTarget, raycastDistance, obstacleLayerMask);
        if (timeStationary > 1f && hitForward.collider != null)
        {
            Debug.Log("Agent Stuck, Calling Unstuck");
            PerformUnstuck(agentPosition, directionToTarget);
            return; // Skip normal movement logic while unstuck logic is active
        }

        if (!enemyInVision && !inDirectorSquare)
        {
            if (isPathCalculated && path.Count > 0)
            {
                Vector2 targetWaypoint = path[0];
                RaycastHit2D hit = Physics2D.Raycast(agentPosition, directionToTarget, raycastDistance, obstacleLayerMask);

                if (hit.collider != null)
                {
                    CalculatePath();
                }
                else
                {
                    MoveTowardsWaypoint(targetWaypoint);
                }

                // Remove the waypoint if close enough
                if (Vector2.Distance(agentPosition, targetWaypoint) < 1f)
                {
                    path.RemoveAt(0);
                }
            }
            else
            {
                Vector2 direction = directionToTarget;
                transform.position += (Vector3)(direction * moveSpeed * Time.deltaTime);
            }
        }
        else
        {
            //FILL
        }
    }

    // Unstuck logic to back up, move laterally, and resume normal pathfinding
    void PerformUnstuck(Vector2 agentPosition, Vector2 forwardDirection)
    {
        Vector2 backDirection = -forwardDirection;
        RaycastHit2D hitBack = Physics2D.Raycast(agentPosition, backDirection, raycastDistance, obstacleLayerMask);

        if (hitBack.collider == null)
        {
            transform.position += (Vector3)(backDirection * moveSpeed * Time.deltaTime);
            return;
        }

        Vector2 lateralDirection = Vector2.Perpendicular(forwardDirection).normalized;

        if (path.Count > 0)
        {
            Vector2 directionToNextWaypoint = (path[0] - agentPosition).normalized;
            lateralDirection = Vector3.Cross(forwardDirection, Vector3.forward).z > 0 ? lateralDirection : -lateralDirection;
        }

        RaycastHit2D hitLateral = Physics2D.Raycast(agentPosition, lateralDirection, raycastDistance, obstacleLayerMask);

        if (hitLateral.collider == null)
        {
            transform.position += (Vector3)(lateralDirection * moveSpeed * Time.deltaTime);
            return;
        }

        if (hitBack.collider != null && hitLateral.collider != null)
        {
            CalculatePath();
        }
    }

    // MoveTowardsWaypoint method remains the same as before
    void MoveTowardsWaypoint(Vector2 waypoint)
    {
        Vector2 moveDirection = (waypoint - (Vector2)transform.position).normalized;
        transform.position += (Vector3)(moveDirection * moveSpeed * Time.deltaTime);

        if (moveDirection != Vector2.zero)
        {
            float angle = Mathf.Atan2(moveDirection.y, moveDirection.x) * Mathf.Rad2Deg;
            transform.rotation = Quaternion.Euler(0, 0, angle);
        }
    }

    void OnDrawGizmos()
    {
        //Draw Calculated Path
        Gizmos.color = Color.red;
        if (path.Count > 0)
        {
            Vector2 previousPoint = path[0];
            foreach (Vector2 point in path)
            {
                //Draw A Line From One Waypoint To The Next
                Gizmos.DrawLine(previousPoint, point);
                previousPoint = point;
            }
        }

        Vector2 currentPosition = transform.position;

        if (path.Count > 0)
        {
            //Colour For Avoidance Rays
            Gizmos.color = Color.blue;
            Vector2 directionToTarget = (path[0] - (Vector2)transform.position).normalized;

            //Ray In Direction Of Movement
            RaycastHit2D hitForward = Physics2D.Raycast(currentPosition, directionToTarget, raycastDistance, obstacleLayerMask);
            if (hitForward.collider != null)
            {
                Gizmos.color = Color.yellow;
                Gizmos.DrawRay(currentPosition, directionToTarget * raycastDistance);
            }
        }
    }
}